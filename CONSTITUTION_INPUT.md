Prioritize simplicity in user-facing design, architecture, and codebase — when choosing between approaches, prefer the one that's easier to explain. Follow software engineering principles: DRY, YAGNI, KISS, separation of concerns, least surprise, composition over inheritance, dependency inversion, loose coupling/high cohesion, single responsibility, explicit over implicit, fail fast, immutability by default, meaningful names. Guard against over-engineering with the Rule of Three (don't abstract until the pattern appears three times), reversibility (prefer decisions easy to undo), and optimize for changeability. Note: DRY and Rule of Three are intentionally in tension — DRY governs knowledge duplication, Rule of Three governs premature abstraction; when they conflict, ask whether you're duplicating knowledge or duplicating code shape. Similarly, reversibility may require small upfront investment that YAGNI would reject — reversibility wins when the cost is low, YAGNI wins when it isn't. Follow test-driven development: write tests before implementation. Invest disproportionately in test quality — tests encode intent not implementation details, prefer fewer well-designed tests over shallow coverage, treat tests as first-class code, and treat hard-to-write tests as design signals. Develop in short sprints each ending with a small concrete deliverable that is ideally user-testable with minimal effort. Each commit should represent a minimum viable unit of work — the smallest change that is internally consistent, passes all tests, and leaves the codebase in a working state. Each minimum viable unit of work should be committed before moving to the next.
